// Code generated by Remoto; DO NOT EDIT.

package example

import (
	"context"
	"encoding/json"
	"io"
	"io/ioutil"
	"mime/multipart"
	"net/http"
	"strconv"

	"github.com/oxtoacart/bpool"
	"github.com/pkg/errors"
)

// FaceboxClient accesses remote Facebox services.
type FaceboxClient struct {
	// endpoint is the HTTP endpoint of the remote server.
	endpoint string
	// httpclient is the http.Client to use to make requests.
	httpclient *http.Client
	// bufs is a buffer pool
	bufs *bpool.BufferPool
}

// NewFaceboxClient makes a new FaceboxClient that will
// use the specified http.Client to make requests.
func NewFaceboxClient(endpoint string, client *http.Client) *FaceboxClient {
	return &FaceboxClient{
		endpoint:   endpoint,
		httpclient: client,
		bufs:       bpool.NewBufferPool(48),
	}
}

func (c *FaceboxClient) Check(ctx context.Context, request *CheckRequest) (*CheckResponse, error) {
	resp, err := c.CheckMulti(ctx, []*CheckRequest{request})
	if err != nil {
		return nil, err
	}
	if len(resp) == 0 {
		return nil, errors.New("Facebox.Check: no response")
	}
	return resp[0], nil
}

func (c *FaceboxClient) CheckMulti(ctx context.Context, requests []*CheckRequest) ([]*CheckResponse, error) {
	b, err := json.Marshal(requests)
	if err != nil {
		return nil, errors.Wrap(err, "Facebox.Check: encode request")
	}
	buf := c.bufs.Get()
	defer c.bufs.Put(buf)
	w := multipart.NewWriter(buf)
	w.WriteField("json", string(b))

	if err := w.Close(); err != nil {
		return nil, errors.Wrap(err, "Facebox.Check: write")
	}
	req, err := http.NewRequest(http.MethodPost, c.endpoint+"/remoto/Facebox.Check", buf)
	if err != nil {
		return nil, errors.Wrap(err, "Facebox.Check: new request")
	}
	req.Header.Set("Content-Type", w.FormDataContentType())
	req = req.WithContext(ctx)
	resp, err := c.httpclient.Do(req)
	if err != nil {
		return nil, errors.Wrap(err, "Facebox.Check: do")
	}
	if resp.StatusCode != http.StatusOK {
		resp.Body.Close()
		return nil, errors.Errorf("Facebox.Check: remote service returned %d", resp.Status)
	}
	b, err = ioutil.ReadAll(resp.Body)
	resp.Body.Close()
	if err != nil {
		return nil, errors.Wrap(err, "Facebox.Check: read response body")
	}
	var resps []*CheckResponse
	if err := json.Unmarshal(b, &resps); err != nil {
		return nil, errors.Wrap(err, "Facebox.Check: decode response body")
	}
	return resps, nil
}

func (c *FaceboxClient) Teach(ctx context.Context, request *TeachRequest) (*TeachResponse, error) {
	resp, err := c.TeachMulti(ctx, []*TeachRequest{request})
	if err != nil {
		return nil, err
	}
	if len(resp) == 0 {
		return nil, errors.New("Facebox.Teach: no response")
	}
	return resp[0], nil
}

func (c *FaceboxClient) TeachMulti(ctx context.Context, requests []*TeachRequest) ([]*TeachResponse, error) {
	b, err := json.Marshal(requests)
	if err != nil {
		return nil, errors.Wrap(err, "Facebox.Teach: encode request")
	}
	buf := c.bufs.Get()
	defer c.bufs.Put(buf)
	w := multipart.NewWriter(buf)
	w.WriteField("json", string(b))

	if err := w.Close(); err != nil {
		return nil, errors.Wrap(err, "Facebox.Teach: write")
	}
	req, err := http.NewRequest(http.MethodPost, c.endpoint+"/remoto/Facebox.Teach", buf)
	if err != nil {
		return nil, errors.Wrap(err, "Facebox.Teach: new request")
	}
	req.Header.Set("Content-Type", w.FormDataContentType())
	req = req.WithContext(ctx)
	resp, err := c.httpclient.Do(req)
	if err != nil {
		return nil, errors.Wrap(err, "Facebox.Teach: do")
	}
	if resp.StatusCode != http.StatusOK {
		resp.Body.Close()
		return nil, errors.Errorf("Facebox.Teach: remote service returned %d", resp.Status)
	}
	b, err = ioutil.ReadAll(resp.Body)
	resp.Body.Close()
	if err != nil {
		return nil, errors.Wrap(err, "Facebox.Teach: read response body")
	}
	var resps []*TeachResponse
	if err := json.Unmarshal(b, &resps); err != nil {
		return nil, errors.Wrap(err, "Facebox.Teach: decode response body")
	}
	return resps, nil
}

type CheckResponse struct {
	Faces []Faces
	// Error is an error message if one occurred.

	Error string
}

type TeachFile struct {
	Image remototypes.File
}

// SetImage sets the file for Image.
func (s *TeachFile) SetImage(r io.Reader, filename string) {
	s.fileImage = r
	s.filenameImage = filename
}

type TeachRequest struct {
	Name string

	TeachFiles []TeachFile
}

type TeachResponse struct {
	// Error is an error message if one occurred.

	Error string
}

type CheckRequest struct {
	Image remototypes.File
}

// SetImage sets the file for Image.
func (s *CheckRequest) SetImage(r io.Reader, filename string) {
	s.fileImage = r
	s.filenameImage = filename
}

type Faces struct {
	Name string

	Matched bool
}
