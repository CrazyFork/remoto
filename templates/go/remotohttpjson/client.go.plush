<%# 

	This is a plush template
	see https://github.com/gobuffalo/plush

%><%

let comment = fn(s) {
	return "// "+s
}

let serverName = fn(serviceName) {
	return serviceName + "Server"
}

let typeString = fn(type) {
	if (type.IsMultiple) {
		return "[]" + type.Name
	}
	return type.Name
}

%>// Code generated by Remoto; DO NOT EDIT.

package <%= def.PackageName %>

import (
	"bytes"
	"context"
	"encoding/json"
	"io/ioutil"
	"net/http"

	"github.com/pkg/errors"
)
<%= for (service) in def.Services { %>
// <%= service.Name %>Client accesses remote <%= service.Name %> services.
type <%= service.Name %>Client struct {
    // endpoint is the HTTP endpoint of the remote server.
    endpoint string
    // httpclient is the http.Client to use to make requests.
    httpclient *http.Client
}

// New<%= service.Name %>Client makes a new <%= service.Name %>Client that will
// use the specified http.Client to make requests.
func New<%= service.Name %>Client(endpoint string, client *http.Client) *<%= service.Name %>Client {
    return &<%= service.Name %>Client{
        endpoint: endpoint,
        httpclient: client,
    }
}

<%= for (method) in service.Methods { %><%= comment(method.Comment) %>
func (c *<%= service.Name %>Client) <%= method.Name %>(ctx context.Context, request *<%= method.RequestType.Name %>) (*<%= method.ResponseType.Name %>, error) {
    resp, err := c.<%= method.Name %>Multi(ctx, request)
    if err != nil {
        return nil, err
    }
    if len(resp) != 1 {
        return nil, errors.Errorf("expected 1 response object, got %d", len(resp))
    }
    if resp[0].Error != "" {
        return nil, errors.New(resp[0].Error)
    }
    return resp[0], nil
}

// <%= method.Name %>Multi is a batch version of <%= method.Name %>.
func (c *<%= service.Name %>Client) <%= method.Name %>Multi(ctx context.Context, requests ...*<%= method.RequestType.Name %>) ([]*<%= method.ResponseType.Name %>, error) {
    b, err := json.Marshal(requests)
    if err != nil {
        return nil, errors.Wrap(err, "encode request")
    }
    r, err := http.NewRequest(http.MethodPost, c.endpoint + "/remoto/<%= service.Name %>.<%= method.Name %>", bytes.NewReader(b))
    if err != nil {
        return nil, errors.Wrap(err, "make request")
    }
    r = r.WithContext(ctx)
    r.Header.Set("Content-Type", "application/json; charset=utf-8")
    resp, err := c.httpclient.Do(r)
    if err != nil {
        return nil, errors.Wrap(err, "do")
    }
    defer resp.Body.Close()
    if resp.StatusCode != http.StatusOK {
        return nil, errors.Errorf("got %d from remote server", resp.StatusCode)
    }
    b, err = ioutil.ReadAll(resp.Body)
    if err != nil {
        return nil, errors.Wrap(err, "read response body")
    }
    var responses []*<%= method.ResponseType.Name %>
    if err := json.Unmarshal(b, &responses); err != nil {
        return nil, errors.Wrap(err, "decode response")
    }
    return responses, nil
}
<% } %><% } %>

<%= for (structure) in unique_structures(def) { %><%= comment(structure.Comment) %>
type <%= structure.Name %> struct {
    <%= for (field) in structure.Fields { %><%= comment(field.Comment) %>
    <%= field.Name %> <%= field.Type.Name %>
    <% } %>
}

<% } %>
