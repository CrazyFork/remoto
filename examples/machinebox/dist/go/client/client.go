// Code generated by Remoto; DO NOT EDIT.

package suggestionbox

import (
	"context"
	"encoding/json"
	"io"
	"io/ioutil"
	"mime/multipart"
	"net/http"
	"strconv"

	"github.com/machinebox/remoto/remototypes"
	"github.com/oxtoacart/bpool"
	"github.com/pkg/errors"
)

// SuggestionboxClient accesses remote Suggestionbox services.
type SuggestionboxClient struct {
	// endpoint is the HTTP endpoint of the remote server.
	endpoint string
	// httpclient is the http.Client to use to make requests.
	httpclient *http.Client
	// bufs is a buffer pool
	bufs *bpool.BufferPool
}

// NewSuggestionboxClient makes a new SuggestionboxClient that will
// use the specified http.Client to make requests.
func NewSuggestionboxClient(endpoint string, client *http.Client) *SuggestionboxClient {
	return &SuggestionboxClient{
		endpoint:   endpoint,
		httpclient: client,
		bufs:       bpool.NewBufferPool(48),
	}
}

func (c *SuggestionboxClient) CreateModel(ctx context.Context, request *CreateModelRequest) (*CreateModelResponse, error) {
	resp, err := c.CreateModelMulti(ctx, []*CreateModelRequest{request})
	if err != nil {
		return nil, err
	}
	if len(resp) == 0 {
		return nil, errors.New("SuggestionboxClient.CreateModel: no response")
	}
	return resp[0], nil
}

func (c *SuggestionboxClient) CreateModelMulti(ctx context.Context, requests []*CreateModelRequest) ([]*CreateModelResponse, error) {
	b, err := json.Marshal(requests)
	if err != nil {
		return nil, errors.Wrap(err, "SuggestionboxClient.CreateModel: encode request")
	}
	buf := c.bufs.Get()
	defer c.bufs.Put(buf)
	w := multipart.NewWriter(buf)
	w.WriteField("json", string(b))
	if files, ok := ctx.Value(contextKeyFiles).(map[string]file); ok {
		for fieldname, file := range files {
			f, err := w.CreateFormFile(fieldname, file.filename)
			if err != nil {
				return nil, errors.Wrap(err, "SuggestionboxClient.CreateModel: create form file")
			}
			if _, err := io.Copy(f, file.r); err != nil {
				return nil, errors.Wrap(err, "SuggestionboxClient.CreateModel: reading file")
			}
			select {
			case <-ctx.Done():
				return nil, ctx.Err()
			default:
			}
		}
	}
	if err := w.Close(); err != nil {
		return nil, errors.Wrap(err, "SuggestionboxClient.CreateModel: write")
	}
	req, err := http.NewRequest(http.MethodPost, c.endpoint+"/remoto/Suggestionbox.CreateModel", buf)
	if err != nil {
		return nil, errors.Wrap(err, "SuggestionboxClient.CreateModel: new request")
	}
	req.Header.Set("Content-Type", w.FormDataContentType())
	req = req.WithContext(ctx)
	resp, err := c.httpclient.Do(req)
	if err != nil {
		return nil, errors.Wrap(err, "SuggestionboxClient.CreateModel: do")
	}
	if resp.StatusCode != http.StatusOK {
		resp.Body.Close()
		return nil, errors.Errorf("SuggestionboxClient.CreateModel: remote service returned %d", resp.Status)
	}
	b, err = ioutil.ReadAll(resp.Body)
	resp.Body.Close()
	if err != nil {
		return nil, errors.Wrap(err, "SuggestionboxClient.CreateModel: read response body")
	}
	var resps []*CreateModelResponse
	if err := json.Unmarshal(b, &resps); err != nil {
		return nil, errors.Wrap(err, "SuggestionboxClient.CreateModel: decode response body")
	}
	return resps, nil
}

func (c *SuggestionboxClient) DeleteModel(ctx context.Context, request *DeleteModelRequest) (*DeleteModelResponse, error) {
	resp, err := c.DeleteModelMulti(ctx, []*DeleteModelRequest{request})
	if err != nil {
		return nil, err
	}
	if len(resp) == 0 {
		return nil, errors.New("SuggestionboxClient.DeleteModel: no response")
	}
	return resp[0], nil
}

func (c *SuggestionboxClient) DeleteModelMulti(ctx context.Context, requests []*DeleteModelRequest) ([]*DeleteModelResponse, error) {
	b, err := json.Marshal(requests)
	if err != nil {
		return nil, errors.Wrap(err, "SuggestionboxClient.DeleteModel: encode request")
	}
	buf := c.bufs.Get()
	defer c.bufs.Put(buf)
	w := multipart.NewWriter(buf)
	w.WriteField("json", string(b))
	if files, ok := ctx.Value(contextKeyFiles).(map[string]file); ok {
		for fieldname, file := range files {
			f, err := w.CreateFormFile(fieldname, file.filename)
			if err != nil {
				return nil, errors.Wrap(err, "SuggestionboxClient.DeleteModel: create form file")
			}
			if _, err := io.Copy(f, file.r); err != nil {
				return nil, errors.Wrap(err, "SuggestionboxClient.DeleteModel: reading file")
			}
			select {
			case <-ctx.Done():
				return nil, ctx.Err()
			default:
			}
		}
	}
	if err := w.Close(); err != nil {
		return nil, errors.Wrap(err, "SuggestionboxClient.DeleteModel: write")
	}
	req, err := http.NewRequest(http.MethodPost, c.endpoint+"/remoto/Suggestionbox.DeleteModel", buf)
	if err != nil {
		return nil, errors.Wrap(err, "SuggestionboxClient.DeleteModel: new request")
	}
	req.Header.Set("Content-Type", w.FormDataContentType())
	req = req.WithContext(ctx)
	resp, err := c.httpclient.Do(req)
	if err != nil {
		return nil, errors.Wrap(err, "SuggestionboxClient.DeleteModel: do")
	}
	if resp.StatusCode != http.StatusOK {
		resp.Body.Close()
		return nil, errors.Errorf("SuggestionboxClient.DeleteModel: remote service returned %d", resp.Status)
	}
	b, err = ioutil.ReadAll(resp.Body)
	resp.Body.Close()
	if err != nil {
		return nil, errors.Wrap(err, "SuggestionboxClient.DeleteModel: read response body")
	}
	var resps []*DeleteModelResponse
	if err := json.Unmarshal(b, &resps); err != nil {
		return nil, errors.Wrap(err, "SuggestionboxClient.DeleteModel: decode response body")
	}
	return resps, nil
}

func (c *SuggestionboxClient) GetState(ctx context.Context, request *GetStateRequest) (*GetStateResponse, error) {
	resp, err := c.GetStateMulti(ctx, []*GetStateRequest{request})
	if err != nil {
		return nil, err
	}
	if len(resp) == 0 {
		return nil, errors.New("SuggestionboxClient.GetState: no response")
	}
	return resp[0], nil
}

func (c *SuggestionboxClient) GetStateMulti(ctx context.Context, requests []*GetStateRequest) ([]*GetStateResponse, error) {
	b, err := json.Marshal(requests)
	if err != nil {
		return nil, errors.Wrap(err, "SuggestionboxClient.GetState: encode request")
	}
	buf := c.bufs.Get()
	defer c.bufs.Put(buf)
	w := multipart.NewWriter(buf)
	w.WriteField("json", string(b))
	if files, ok := ctx.Value(contextKeyFiles).(map[string]file); ok {
		for fieldname, file := range files {
			f, err := w.CreateFormFile(fieldname, file.filename)
			if err != nil {
				return nil, errors.Wrap(err, "SuggestionboxClient.GetState: create form file")
			}
			if _, err := io.Copy(f, file.r); err != nil {
				return nil, errors.Wrap(err, "SuggestionboxClient.GetState: reading file")
			}
			select {
			case <-ctx.Done():
				return nil, ctx.Err()
			default:
			}
		}
	}
	if err := w.Close(); err != nil {
		return nil, errors.Wrap(err, "SuggestionboxClient.GetState: write")
	}
	req, err := http.NewRequest(http.MethodPost, c.endpoint+"/remoto/Suggestionbox.GetState", buf)
	if err != nil {
		return nil, errors.Wrap(err, "SuggestionboxClient.GetState: new request")
	}
	req.Header.Set("Content-Type", w.FormDataContentType())
	req = req.WithContext(ctx)
	resp, err := c.httpclient.Do(req)
	if err != nil {
		return nil, errors.Wrap(err, "SuggestionboxClient.GetState: do")
	}
	if resp.StatusCode != http.StatusOK {
		resp.Body.Close()
		return nil, errors.Errorf("SuggestionboxClient.GetState: remote service returned %d", resp.Status)
	}
	b, err = ioutil.ReadAll(resp.Body)
	resp.Body.Close()
	if err != nil {
		return nil, errors.Wrap(err, "SuggestionboxClient.GetState: read response body")
	}
	var resps []*GetStateResponse
	if err := json.Unmarshal(b, &resps); err != nil {
		return nil, errors.Wrap(err, "SuggestionboxClient.GetState: decode response body")
	}
	return resps, nil
}

func (c *SuggestionboxClient) ListModels(ctx context.Context, request *ListModelsRequest) (*ListModelsResponse, error) {
	resp, err := c.ListModelsMulti(ctx, []*ListModelsRequest{request})
	if err != nil {
		return nil, err
	}
	if len(resp) == 0 {
		return nil, errors.New("SuggestionboxClient.ListModels: no response")
	}
	return resp[0], nil
}

func (c *SuggestionboxClient) ListModelsMulti(ctx context.Context, requests []*ListModelsRequest) ([]*ListModelsResponse, error) {
	b, err := json.Marshal(requests)
	if err != nil {
		return nil, errors.Wrap(err, "SuggestionboxClient.ListModels: encode request")
	}
	buf := c.bufs.Get()
	defer c.bufs.Put(buf)
	w := multipart.NewWriter(buf)
	w.WriteField("json", string(b))
	if files, ok := ctx.Value(contextKeyFiles).(map[string]file); ok {
		for fieldname, file := range files {
			f, err := w.CreateFormFile(fieldname, file.filename)
			if err != nil {
				return nil, errors.Wrap(err, "SuggestionboxClient.ListModels: create form file")
			}
			if _, err := io.Copy(f, file.r); err != nil {
				return nil, errors.Wrap(err, "SuggestionboxClient.ListModels: reading file")
			}
			select {
			case <-ctx.Done():
				return nil, ctx.Err()
			default:
			}
		}
	}
	if err := w.Close(); err != nil {
		return nil, errors.Wrap(err, "SuggestionboxClient.ListModels: write")
	}
	req, err := http.NewRequest(http.MethodPost, c.endpoint+"/remoto/Suggestionbox.ListModels", buf)
	if err != nil {
		return nil, errors.Wrap(err, "SuggestionboxClient.ListModels: new request")
	}
	req.Header.Set("Content-Type", w.FormDataContentType())
	req = req.WithContext(ctx)
	resp, err := c.httpclient.Do(req)
	if err != nil {
		return nil, errors.Wrap(err, "SuggestionboxClient.ListModels: do")
	}
	if resp.StatusCode != http.StatusOK {
		resp.Body.Close()
		return nil, errors.Errorf("SuggestionboxClient.ListModels: remote service returned %d", resp.Status)
	}
	b, err = ioutil.ReadAll(resp.Body)
	resp.Body.Close()
	if err != nil {
		return nil, errors.Wrap(err, "SuggestionboxClient.ListModels: read response body")
	}
	var resps []*ListModelsResponse
	if err := json.Unmarshal(b, &resps); err != nil {
		return nil, errors.Wrap(err, "SuggestionboxClient.ListModels: decode response body")
	}
	return resps, nil
}

func (c *SuggestionboxClient) Predict(ctx context.Context, request *PredictRequest) (*PredictResponse, error) {
	resp, err := c.PredictMulti(ctx, []*PredictRequest{request})
	if err != nil {
		return nil, err
	}
	if len(resp) == 0 {
		return nil, errors.New("SuggestionboxClient.Predict: no response")
	}
	return resp[0], nil
}

func (c *SuggestionboxClient) PredictMulti(ctx context.Context, requests []*PredictRequest) ([]*PredictResponse, error) {
	b, err := json.Marshal(requests)
	if err != nil {
		return nil, errors.Wrap(err, "SuggestionboxClient.Predict: encode request")
	}
	buf := c.bufs.Get()
	defer c.bufs.Put(buf)
	w := multipart.NewWriter(buf)
	w.WriteField("json", string(b))
	if files, ok := ctx.Value(contextKeyFiles).(map[string]file); ok {
		for fieldname, file := range files {
			f, err := w.CreateFormFile(fieldname, file.filename)
			if err != nil {
				return nil, errors.Wrap(err, "SuggestionboxClient.Predict: create form file")
			}
			if _, err := io.Copy(f, file.r); err != nil {
				return nil, errors.Wrap(err, "SuggestionboxClient.Predict: reading file")
			}
			select {
			case <-ctx.Done():
				return nil, ctx.Err()
			default:
			}
		}
	}
	if err := w.Close(); err != nil {
		return nil, errors.Wrap(err, "SuggestionboxClient.Predict: write")
	}
	req, err := http.NewRequest(http.MethodPost, c.endpoint+"/remoto/Suggestionbox.Predict", buf)
	if err != nil {
		return nil, errors.Wrap(err, "SuggestionboxClient.Predict: new request")
	}
	req.Header.Set("Content-Type", w.FormDataContentType())
	req = req.WithContext(ctx)
	resp, err := c.httpclient.Do(req)
	if err != nil {
		return nil, errors.Wrap(err, "SuggestionboxClient.Predict: do")
	}
	if resp.StatusCode != http.StatusOK {
		resp.Body.Close()
		return nil, errors.Errorf("SuggestionboxClient.Predict: remote service returned %d", resp.Status)
	}
	b, err = ioutil.ReadAll(resp.Body)
	resp.Body.Close()
	if err != nil {
		return nil, errors.Wrap(err, "SuggestionboxClient.Predict: read response body")
	}
	var resps []*PredictResponse
	if err := json.Unmarshal(b, &resps); err != nil {
		return nil, errors.Wrap(err, "SuggestionboxClient.Predict: decode response body")
	}
	return resps, nil
}

func (c *SuggestionboxClient) PutState(ctx context.Context, request *PutStateRequest) (*PutStateResponse, error) {
	resp, err := c.PutStateMulti(ctx, []*PutStateRequest{request})
	if err != nil {
		return nil, err
	}
	if len(resp) == 0 {
		return nil, errors.New("SuggestionboxClient.PutState: no response")
	}
	return resp[0], nil
}

func (c *SuggestionboxClient) PutStateMulti(ctx context.Context, requests []*PutStateRequest) ([]*PutStateResponse, error) {
	b, err := json.Marshal(requests)
	if err != nil {
		return nil, errors.Wrap(err, "SuggestionboxClient.PutState: encode request")
	}
	buf := c.bufs.Get()
	defer c.bufs.Put(buf)
	w := multipart.NewWriter(buf)
	w.WriteField("json", string(b))
	if files, ok := ctx.Value(contextKeyFiles).(map[string]file); ok {
		for fieldname, file := range files {
			f, err := w.CreateFormFile(fieldname, file.filename)
			if err != nil {
				return nil, errors.Wrap(err, "SuggestionboxClient.PutState: create form file")
			}
			if _, err := io.Copy(f, file.r); err != nil {
				return nil, errors.Wrap(err, "SuggestionboxClient.PutState: reading file")
			}
			select {
			case <-ctx.Done():
				return nil, ctx.Err()
			default:
			}
		}
	}
	if err := w.Close(); err != nil {
		return nil, errors.Wrap(err, "SuggestionboxClient.PutState: write")
	}
	req, err := http.NewRequest(http.MethodPost, c.endpoint+"/remoto/Suggestionbox.PutState", buf)
	if err != nil {
		return nil, errors.Wrap(err, "SuggestionboxClient.PutState: new request")
	}
	req.Header.Set("Content-Type", w.FormDataContentType())
	req = req.WithContext(ctx)
	resp, err := c.httpclient.Do(req)
	if err != nil {
		return nil, errors.Wrap(err, "SuggestionboxClient.PutState: do")
	}
	if resp.StatusCode != http.StatusOK {
		resp.Body.Close()
		return nil, errors.Errorf("SuggestionboxClient.PutState: remote service returned %d", resp.Status)
	}
	b, err = ioutil.ReadAll(resp.Body)
	resp.Body.Close()
	if err != nil {
		return nil, errors.Wrap(err, "SuggestionboxClient.PutState: read response body")
	}
	var resps []*PutStateResponse
	if err := json.Unmarshal(b, &resps); err != nil {
		return nil, errors.Wrap(err, "SuggestionboxClient.PutState: decode response body")
	}
	return resps, nil
}

func (c *SuggestionboxClient) Reward(ctx context.Context, request *RewardRequest) (*RewardResponse, error) {
	resp, err := c.RewardMulti(ctx, []*RewardRequest{request})
	if err != nil {
		return nil, err
	}
	if len(resp) == 0 {
		return nil, errors.New("SuggestionboxClient.Reward: no response")
	}
	return resp[0], nil
}

func (c *SuggestionboxClient) RewardMulti(ctx context.Context, requests []*RewardRequest) ([]*RewardResponse, error) {
	b, err := json.Marshal(requests)
	if err != nil {
		return nil, errors.Wrap(err, "SuggestionboxClient.Reward: encode request")
	}
	buf := c.bufs.Get()
	defer c.bufs.Put(buf)
	w := multipart.NewWriter(buf)
	w.WriteField("json", string(b))
	if files, ok := ctx.Value(contextKeyFiles).(map[string]file); ok {
		for fieldname, file := range files {
			f, err := w.CreateFormFile(fieldname, file.filename)
			if err != nil {
				return nil, errors.Wrap(err, "SuggestionboxClient.Reward: create form file")
			}
			if _, err := io.Copy(f, file.r); err != nil {
				return nil, errors.Wrap(err, "SuggestionboxClient.Reward: reading file")
			}
			select {
			case <-ctx.Done():
				return nil, ctx.Err()
			default:
			}
		}
	}
	if err := w.Close(); err != nil {
		return nil, errors.Wrap(err, "SuggestionboxClient.Reward: write")
	}
	req, err := http.NewRequest(http.MethodPost, c.endpoint+"/remoto/Suggestionbox.Reward", buf)
	if err != nil {
		return nil, errors.Wrap(err, "SuggestionboxClient.Reward: new request")
	}
	req.Header.Set("Content-Type", w.FormDataContentType())
	req = req.WithContext(ctx)
	resp, err := c.httpclient.Do(req)
	if err != nil {
		return nil, errors.Wrap(err, "SuggestionboxClient.Reward: do")
	}
	if resp.StatusCode != http.StatusOK {
		resp.Body.Close()
		return nil, errors.Errorf("SuggestionboxClient.Reward: remote service returned %d", resp.Status)
	}
	b, err = ioutil.ReadAll(resp.Body)
	resp.Body.Close()
	if err != nil {
		return nil, errors.Wrap(err, "SuggestionboxClient.Reward: read response body")
	}
	var resps []*RewardResponse
	if err := json.Unmarshal(b, &resps); err != nil {
		return nil, errors.Wrap(err, "SuggestionboxClient.Reward: decode response body")
	}
	return resps, nil
}

type ListModelsResponse struct {
	Models []Model

	// Error is an error message if one occurred.
	Error string
}

type PredictResponse struct {
	Choices []PredictedChoice

	// Error is an error message if one occurred.
	Error string
}

type RewardResponse struct {

	// Error is an error message if one occurred.
	Error string
}

type CreateModelRequest struct {
	Model Model
}

type CreateModelResponse struct {

	// Error is an error message if one occurred.
	Error string
}

type DeleteModelRequest struct {
	ModelID string
}

type DeleteModelResponse struct {

	// Error is an error message if one occurred.
	Error string
}

type PredictedChoice struct {
	ID string

	Features []Feature

	RewardID string
}

type Feature struct {
	Key string

	Type string

	Value string

	File remototypes.File
}

// SetFile puts a file into the context ready for the request.
func (s *Feature) SetFile(ctx context.Context, filename string, r io.Reader) context.Context {
	files, ok := ctx.Value(contextKeyFiles).(map[string]file)
	if !ok {
		files = make(map[string]file)
	}
	fieldname := "files[" + strconv.Itoa(len(files)) + "]"
	files[fieldname] = file{r: r, filename: filename}
	ctx = context.WithValue(ctx, contextKeyFiles, files)
	s.File = remototypes.NewFile(fieldname)
	return ctx
}

type Choice struct {
	ID string

	Features []Feature
}

type PredictRequest struct {
	ModelID string

	Limit int

	Inputs []Feature
}

type RewardRequest struct {
	ModelID string

	RewardID string

	Value int
}

type GetStateResponse struct {
	StateFile remototypes.File

	// Error is an error message if one occurred.
	Error string
}

// SetStateFile puts a file into the context ready for the request.
func (s *GetStateResponse) SetStateFile(ctx context.Context, filename string, r io.Reader) context.Context {
	files, ok := ctx.Value(contextKeyFiles).(map[string]file)
	if !ok {
		files = make(map[string]file)
	}
	fieldname := "files[" + strconv.Itoa(len(files)) + "]"
	files[fieldname] = file{r: r, filename: filename}
	ctx = context.WithValue(ctx, contextKeyFiles, files)
	s.StateFile = remototypes.NewFile(fieldname)
	return ctx
}

type ListModelsRequest struct {
}

type GetStateRequest struct {
}

type PutStateRequest struct {
	StateFile remototypes.File
}

// SetStateFile puts a file into the context ready for the request.
func (s *PutStateRequest) SetStateFile(ctx context.Context, filename string, r io.Reader) context.Context {
	files, ok := ctx.Value(contextKeyFiles).(map[string]file)
	if !ok {
		files = make(map[string]file)
	}
	fieldname := "files[" + strconv.Itoa(len(files)) + "]"
	files[fieldname] = file{r: r, filename: filename}
	ctx = context.WithValue(ctx, contextKeyFiles, files)
	s.StateFile = remototypes.NewFile(fieldname)
	return ctx
}

type PutStateResponse struct {

	// Error is an error message if one occurred.
	Error string
}

type ModelOptions struct {
	RewardExpirationSeconds int

	Ngrams int

	Skipgrams int

	Mode string

	Epsilon float64

	Cover float64
}

type Model struct {
	ID string

	Name string

	Options ModelOptions

	Choices []Choice
}

type contextKey string

func (c contextKey) String() string {
	return "remoto context key: " + string(c)
}

var contextKeyFiles = contextKey("files")

type file struct {
	r        io.Reader
	filename string
}

// this is here so we don't get a compiler complaint about
// importing remototypes but not using it.
var _ = remototypes.File("ignore me")
