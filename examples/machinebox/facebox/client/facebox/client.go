// Code generated by Remoto; DO NOT EDIT.

package facebox

import (
	"context"
	"encoding/json"
	"io"
	"io/ioutil"
	"mime/multipart"
	"net/http"
	"strconv"

	"github.com/machinebox/remoto/remototypes"
	"github.com/oxtoacart/bpool"
	"github.com/pkg/errors"
)

// FaceboxClient accesses remote Facebox services.
type FaceboxClient struct {
	// endpoint is the HTTP endpoint of the remote server.
	endpoint string
	// httpclient is the http.Client to use to make requests.
	httpclient *http.Client
	// bufs is a buffer pool
	bufs *bpool.BufferPool
}

// NewFaceboxClient makes a new FaceboxClient that will
// use the specified http.Client to make requests.
func NewFaceboxClient(endpoint string, client *http.Client) *FaceboxClient {
	return &FaceboxClient{
		endpoint:   endpoint,
		httpclient: client,
		bufs:       bpool.NewBufferPool(48),
	}
}

func (c *FaceboxClient) CheckFaceprint(ctx context.Context, request *CheckFaceprintRequest) (*CheckFaceprintResponse, error) {
	resp, err := c.CheckFaceprintMulti(ctx, []*CheckFaceprintRequest{request})
	if err != nil {
		return nil, err
	}
	if len(resp) == 0 {
		return nil, errors.New("FaceboxClient.CheckFaceprint: no response")
	}
	return resp[0], nil
}

func (c *FaceboxClient) CheckFaceprintMulti(ctx context.Context, requests []*CheckFaceprintRequest) ([]*CheckFaceprintResponse, error) {
	b, err := json.Marshal(requests)
	if err != nil {
		return nil, errors.Wrap(err, "FaceboxClient.CheckFaceprint: encode request")
	}
	buf := c.bufs.Get()
	defer c.bufs.Put(buf)
	w := multipart.NewWriter(buf)
	w.WriteField("json", string(b))
	if files, ok := ctx.Value(contextKeyFiles).(map[string]file); ok {
		for fieldname, file := range files {
			f, err := w.CreateFormFile(fieldname, file.filename)
			if err != nil {
				return nil, errors.Wrap(err, "FaceboxClient.CheckFaceprint: create form file")
			}
			if _, err := io.Copy(f, file.r); err != nil {
				return nil, errors.Wrap(err, "FaceboxClient.CheckFaceprint: reading file")
			}
			select {
			case <-ctx.Done():
				return nil, ctx.Err()
			default:
			}
		}
	}
	if err := w.Close(); err != nil {
		return nil, errors.Wrap(err, "FaceboxClient.CheckFaceprint: write")
	}
	req, err := http.NewRequest(http.MethodPost, c.endpoint+"/remoto/Facebox.CheckFaceprint", buf)
	if err != nil {
		return nil, errors.Wrap(err, "FaceboxClient.CheckFaceprint: new request")
	}
	req.Header.Set("Accept", "application/json; charset=utf-8")
	req.Header.Set("Content-Type", w.FormDataContentType())
	req = req.WithContext(ctx)
	resp, err := c.httpclient.Do(req)
	if err != nil {
		return nil, errors.Wrap(err, "FaceboxClient.CheckFaceprint: do")
	}
	if resp.StatusCode != http.StatusOK {
		resp.Body.Close()
		return nil, errors.Errorf("FaceboxClient.CheckFaceprint: remote service returned %s", resp.Status)
	}
	b, err = ioutil.ReadAll(resp.Body)
	resp.Body.Close()
	if err != nil {
		return nil, errors.Wrap(err, "FaceboxClient.CheckFaceprint: read response body")
	}
	var resps []*CheckFaceprintResponse
	if err := json.Unmarshal(b, &resps); err != nil {
		return nil, errors.Wrap(err, "FaceboxClient.CheckFaceprint: decode response body")
	}
	return resps, nil
}

func (c *FaceboxClient) CheckFile(ctx context.Context, request *CheckFileRequest) (*CheckFileResponse, error) {
	resp, err := c.CheckFileMulti(ctx, []*CheckFileRequest{request})
	if err != nil {
		return nil, err
	}
	if len(resp) == 0 {
		return nil, errors.New("FaceboxClient.CheckFile: no response")
	}
	return resp[0], nil
}

func (c *FaceboxClient) CheckFileMulti(ctx context.Context, requests []*CheckFileRequest) ([]*CheckFileResponse, error) {
	b, err := json.Marshal(requests)
	if err != nil {
		return nil, errors.Wrap(err, "FaceboxClient.CheckFile: encode request")
	}
	buf := c.bufs.Get()
	defer c.bufs.Put(buf)
	w := multipart.NewWriter(buf)
	w.WriteField("json", string(b))
	if files, ok := ctx.Value(contextKeyFiles).(map[string]file); ok {
		for fieldname, file := range files {
			f, err := w.CreateFormFile(fieldname, file.filename)
			if err != nil {
				return nil, errors.Wrap(err, "FaceboxClient.CheckFile: create form file")
			}
			if _, err := io.Copy(f, file.r); err != nil {
				return nil, errors.Wrap(err, "FaceboxClient.CheckFile: reading file")
			}
			select {
			case <-ctx.Done():
				return nil, ctx.Err()
			default:
			}
		}
	}
	if err := w.Close(); err != nil {
		return nil, errors.Wrap(err, "FaceboxClient.CheckFile: write")
	}
	req, err := http.NewRequest(http.MethodPost, c.endpoint+"/remoto/Facebox.CheckFile", buf)
	if err != nil {
		return nil, errors.Wrap(err, "FaceboxClient.CheckFile: new request")
	}
	req.Header.Set("Accept", "application/json; charset=utf-8")
	req.Header.Set("Content-Type", w.FormDataContentType())
	req = req.WithContext(ctx)
	resp, err := c.httpclient.Do(req)
	if err != nil {
		return nil, errors.Wrap(err, "FaceboxClient.CheckFile: do")
	}
	if resp.StatusCode != http.StatusOK {
		resp.Body.Close()
		return nil, errors.Errorf("FaceboxClient.CheckFile: remote service returned %s", resp.Status)
	}
	b, err = ioutil.ReadAll(resp.Body)
	resp.Body.Close()
	if err != nil {
		return nil, errors.Wrap(err, "FaceboxClient.CheckFile: read response body")
	}
	var resps []*CheckFileResponse
	if err := json.Unmarshal(b, &resps); err != nil {
		return nil, errors.Wrap(err, "FaceboxClient.CheckFile: decode response body")
	}
	return resps, nil
}

func (c *FaceboxClient) CheckURL(ctx context.Context, request *CheckURLRequest) (*CheckURLResponse, error) {
	resp, err := c.CheckURLMulti(ctx, []*CheckURLRequest{request})
	if err != nil {
		return nil, err
	}
	if len(resp) == 0 {
		return nil, errors.New("FaceboxClient.CheckURL: no response")
	}
	return resp[0], nil
}

func (c *FaceboxClient) CheckURLMulti(ctx context.Context, requests []*CheckURLRequest) ([]*CheckURLResponse, error) {
	b, err := json.Marshal(requests)
	if err != nil {
		return nil, errors.Wrap(err, "FaceboxClient.CheckURL: encode request")
	}
	buf := c.bufs.Get()
	defer c.bufs.Put(buf)
	w := multipart.NewWriter(buf)
	w.WriteField("json", string(b))
	if files, ok := ctx.Value(contextKeyFiles).(map[string]file); ok {
		for fieldname, file := range files {
			f, err := w.CreateFormFile(fieldname, file.filename)
			if err != nil {
				return nil, errors.Wrap(err, "FaceboxClient.CheckURL: create form file")
			}
			if _, err := io.Copy(f, file.r); err != nil {
				return nil, errors.Wrap(err, "FaceboxClient.CheckURL: reading file")
			}
			select {
			case <-ctx.Done():
				return nil, ctx.Err()
			default:
			}
		}
	}
	if err := w.Close(); err != nil {
		return nil, errors.Wrap(err, "FaceboxClient.CheckURL: write")
	}
	req, err := http.NewRequest(http.MethodPost, c.endpoint+"/remoto/Facebox.CheckURL", buf)
	if err != nil {
		return nil, errors.Wrap(err, "FaceboxClient.CheckURL: new request")
	}
	req.Header.Set("Accept", "application/json; charset=utf-8")
	req.Header.Set("Content-Type", w.FormDataContentType())
	req = req.WithContext(ctx)
	resp, err := c.httpclient.Do(req)
	if err != nil {
		return nil, errors.Wrap(err, "FaceboxClient.CheckURL: do")
	}
	if resp.StatusCode != http.StatusOK {
		resp.Body.Close()
		return nil, errors.Errorf("FaceboxClient.CheckURL: remote service returned %s", resp.Status)
	}
	b, err = ioutil.ReadAll(resp.Body)
	resp.Body.Close()
	if err != nil {
		return nil, errors.Wrap(err, "FaceboxClient.CheckURL: read response body")
	}
	var resps []*CheckURLResponse
	if err := json.Unmarshal(b, &resps); err != nil {
		return nil, errors.Wrap(err, "FaceboxClient.CheckURL: decode response body")
	}
	return resps, nil
}

func (c *FaceboxClient) FaceprintCompare(ctx context.Context, request *FaceprintCompareRequest) (*FaceprintCompareResponse, error) {
	resp, err := c.FaceprintCompareMulti(ctx, []*FaceprintCompareRequest{request})
	if err != nil {
		return nil, err
	}
	if len(resp) == 0 {
		return nil, errors.New("FaceboxClient.FaceprintCompare: no response")
	}
	return resp[0], nil
}

func (c *FaceboxClient) FaceprintCompareMulti(ctx context.Context, requests []*FaceprintCompareRequest) ([]*FaceprintCompareResponse, error) {
	b, err := json.Marshal(requests)
	if err != nil {
		return nil, errors.Wrap(err, "FaceboxClient.FaceprintCompare: encode request")
	}
	buf := c.bufs.Get()
	defer c.bufs.Put(buf)
	w := multipart.NewWriter(buf)
	w.WriteField("json", string(b))
	if files, ok := ctx.Value(contextKeyFiles).(map[string]file); ok {
		for fieldname, file := range files {
			f, err := w.CreateFormFile(fieldname, file.filename)
			if err != nil {
				return nil, errors.Wrap(err, "FaceboxClient.FaceprintCompare: create form file")
			}
			if _, err := io.Copy(f, file.r); err != nil {
				return nil, errors.Wrap(err, "FaceboxClient.FaceprintCompare: reading file")
			}
			select {
			case <-ctx.Done():
				return nil, ctx.Err()
			default:
			}
		}
	}
	if err := w.Close(); err != nil {
		return nil, errors.Wrap(err, "FaceboxClient.FaceprintCompare: write")
	}
	req, err := http.NewRequest(http.MethodPost, c.endpoint+"/remoto/Facebox.FaceprintCompare", buf)
	if err != nil {
		return nil, errors.Wrap(err, "FaceboxClient.FaceprintCompare: new request")
	}
	req.Header.Set("Accept", "application/json; charset=utf-8")
	req.Header.Set("Content-Type", w.FormDataContentType())
	req = req.WithContext(ctx)
	resp, err := c.httpclient.Do(req)
	if err != nil {
		return nil, errors.Wrap(err, "FaceboxClient.FaceprintCompare: do")
	}
	if resp.StatusCode != http.StatusOK {
		resp.Body.Close()
		return nil, errors.Errorf("FaceboxClient.FaceprintCompare: remote service returned %s", resp.Status)
	}
	b, err = ioutil.ReadAll(resp.Body)
	resp.Body.Close()
	if err != nil {
		return nil, errors.Wrap(err, "FaceboxClient.FaceprintCompare: read response body")
	}
	var resps []*FaceprintCompareResponse
	if err := json.Unmarshal(b, &resps); err != nil {
		return nil, errors.Wrap(err, "FaceboxClient.FaceprintCompare: decode response body")
	}
	return resps, nil
}

func (c *FaceboxClient) GetState(ctx context.Context, request *GetStateRequest) (io.ReadCloser, error) {
	b, err := json.Marshal([]interface{}{request})
	if err != nil {
		return nil, errors.Wrap(err, "FaceboxClient.GetState: encode request")
	}
	buf := c.bufs.Get()
	defer c.bufs.Put(buf)
	w := multipart.NewWriter(buf)
	w.WriteField("json", string(b))
	if files, ok := ctx.Value(contextKeyFiles).(map[string]file); ok {
		for fieldname, file := range files {
			f, err := w.CreateFormFile(fieldname, file.filename)
			if err != nil {
				return nil, errors.Wrap(err, "FaceboxClient.GetState: create form file")
			}
			if _, err := io.Copy(f, file.r); err != nil {
				return nil, errors.Wrap(err, "FaceboxClient.GetState: reading file")
			}
			select {
			case <-ctx.Done():
				return nil, ctx.Err()
			default:
			}
		}
	}
	if err := w.Close(); err != nil {
		return nil, errors.Wrap(err, "FaceboxClient.GetState: write")
	}
	req, err := http.NewRequest(http.MethodPost, c.endpoint+"/remoto/Facebox.GetState", buf)
	if err != nil {
		return nil, errors.Wrap(err, "FaceboxClient.GetState: new request")
	}
	req.Header.Set("Accept", "application/json; charset=utf-8")
	req.Header.Set("Content-Type", w.FormDataContentType())
	req = req.WithContext(ctx)
	resp, err := c.httpclient.Do(req)
	if err != nil {
		return nil, errors.Wrap(err, "FaceboxClient.GetState: do")
	}
	if resp.StatusCode != http.StatusOK {
		resp.Body.Close()
		return nil, errors.Errorf("FaceboxClient.GetState: remote service returned %s", resp.Status)
	}
	return resp.Body, nil
}

func (c *FaceboxClient) PutState(ctx context.Context, request *PutStateRequest) (*PutStateResponse, error) {
	resp, err := c.PutStateMulti(ctx, []*PutStateRequest{request})
	if err != nil {
		return nil, err
	}
	if len(resp) == 0 {
		return nil, errors.New("FaceboxClient.PutState: no response")
	}
	return resp[0], nil
}

func (c *FaceboxClient) PutStateMulti(ctx context.Context, requests []*PutStateRequest) ([]*PutStateResponse, error) {
	b, err := json.Marshal(requests)
	if err != nil {
		return nil, errors.Wrap(err, "FaceboxClient.PutState: encode request")
	}
	buf := c.bufs.Get()
	defer c.bufs.Put(buf)
	w := multipart.NewWriter(buf)
	w.WriteField("json", string(b))
	if files, ok := ctx.Value(contextKeyFiles).(map[string]file); ok {
		for fieldname, file := range files {
			f, err := w.CreateFormFile(fieldname, file.filename)
			if err != nil {
				return nil, errors.Wrap(err, "FaceboxClient.PutState: create form file")
			}
			if _, err := io.Copy(f, file.r); err != nil {
				return nil, errors.Wrap(err, "FaceboxClient.PutState: reading file")
			}
			select {
			case <-ctx.Done():
				return nil, ctx.Err()
			default:
			}
		}
	}
	if err := w.Close(); err != nil {
		return nil, errors.Wrap(err, "FaceboxClient.PutState: write")
	}
	req, err := http.NewRequest(http.MethodPost, c.endpoint+"/remoto/Facebox.PutState", buf)
	if err != nil {
		return nil, errors.Wrap(err, "FaceboxClient.PutState: new request")
	}
	req.Header.Set("Accept", "application/json; charset=utf-8")
	req.Header.Set("Content-Type", w.FormDataContentType())
	req = req.WithContext(ctx)
	resp, err := c.httpclient.Do(req)
	if err != nil {
		return nil, errors.Wrap(err, "FaceboxClient.PutState: do")
	}
	if resp.StatusCode != http.StatusOK {
		resp.Body.Close()
		return nil, errors.Errorf("FaceboxClient.PutState: remote service returned %s", resp.Status)
	}
	b, err = ioutil.ReadAll(resp.Body)
	resp.Body.Close()
	if err != nil {
		return nil, errors.Wrap(err, "FaceboxClient.PutState: read response body")
	}
	var resps []*PutStateResponse
	if err := json.Unmarshal(b, &resps); err != nil {
		return nil, errors.Wrap(err, "FaceboxClient.PutState: decode response body")
	}
	return resps, nil
}

func (c *FaceboxClient) RemoveID(ctx context.Context, request *RemoveIDRequest) (*RemoveIDResponse, error) {
	resp, err := c.RemoveIDMulti(ctx, []*RemoveIDRequest{request})
	if err != nil {
		return nil, err
	}
	if len(resp) == 0 {
		return nil, errors.New("FaceboxClient.RemoveID: no response")
	}
	return resp[0], nil
}

func (c *FaceboxClient) RemoveIDMulti(ctx context.Context, requests []*RemoveIDRequest) ([]*RemoveIDResponse, error) {
	b, err := json.Marshal(requests)
	if err != nil {
		return nil, errors.Wrap(err, "FaceboxClient.RemoveID: encode request")
	}
	buf := c.bufs.Get()
	defer c.bufs.Put(buf)
	w := multipart.NewWriter(buf)
	w.WriteField("json", string(b))
	if files, ok := ctx.Value(contextKeyFiles).(map[string]file); ok {
		for fieldname, file := range files {
			f, err := w.CreateFormFile(fieldname, file.filename)
			if err != nil {
				return nil, errors.Wrap(err, "FaceboxClient.RemoveID: create form file")
			}
			if _, err := io.Copy(f, file.r); err != nil {
				return nil, errors.Wrap(err, "FaceboxClient.RemoveID: reading file")
			}
			select {
			case <-ctx.Done():
				return nil, ctx.Err()
			default:
			}
		}
	}
	if err := w.Close(); err != nil {
		return nil, errors.Wrap(err, "FaceboxClient.RemoveID: write")
	}
	req, err := http.NewRequest(http.MethodPost, c.endpoint+"/remoto/Facebox.RemoveID", buf)
	if err != nil {
		return nil, errors.Wrap(err, "FaceboxClient.RemoveID: new request")
	}
	req.Header.Set("Accept", "application/json; charset=utf-8")
	req.Header.Set("Content-Type", w.FormDataContentType())
	req = req.WithContext(ctx)
	resp, err := c.httpclient.Do(req)
	if err != nil {
		return nil, errors.Wrap(err, "FaceboxClient.RemoveID: do")
	}
	if resp.StatusCode != http.StatusOK {
		resp.Body.Close()
		return nil, errors.Errorf("FaceboxClient.RemoveID: remote service returned %s", resp.Status)
	}
	b, err = ioutil.ReadAll(resp.Body)
	resp.Body.Close()
	if err != nil {
		return nil, errors.Wrap(err, "FaceboxClient.RemoveID: read response body")
	}
	var resps []*RemoveIDResponse
	if err := json.Unmarshal(b, &resps); err != nil {
		return nil, errors.Wrap(err, "FaceboxClient.RemoveID: decode response body")
	}
	return resps, nil
}

func (c *FaceboxClient) Rename(ctx context.Context, request *RenameRequest) (*RenameResponse, error) {
	resp, err := c.RenameMulti(ctx, []*RenameRequest{request})
	if err != nil {
		return nil, err
	}
	if len(resp) == 0 {
		return nil, errors.New("FaceboxClient.Rename: no response")
	}
	return resp[0], nil
}

func (c *FaceboxClient) RenameMulti(ctx context.Context, requests []*RenameRequest) ([]*RenameResponse, error) {
	b, err := json.Marshal(requests)
	if err != nil {
		return nil, errors.Wrap(err, "FaceboxClient.Rename: encode request")
	}
	buf := c.bufs.Get()
	defer c.bufs.Put(buf)
	w := multipart.NewWriter(buf)
	w.WriteField("json", string(b))
	if files, ok := ctx.Value(contextKeyFiles).(map[string]file); ok {
		for fieldname, file := range files {
			f, err := w.CreateFormFile(fieldname, file.filename)
			if err != nil {
				return nil, errors.Wrap(err, "FaceboxClient.Rename: create form file")
			}
			if _, err := io.Copy(f, file.r); err != nil {
				return nil, errors.Wrap(err, "FaceboxClient.Rename: reading file")
			}
			select {
			case <-ctx.Done():
				return nil, ctx.Err()
			default:
			}
		}
	}
	if err := w.Close(); err != nil {
		return nil, errors.Wrap(err, "FaceboxClient.Rename: write")
	}
	req, err := http.NewRequest(http.MethodPost, c.endpoint+"/remoto/Facebox.Rename", buf)
	if err != nil {
		return nil, errors.Wrap(err, "FaceboxClient.Rename: new request")
	}
	req.Header.Set("Accept", "application/json; charset=utf-8")
	req.Header.Set("Content-Type", w.FormDataContentType())
	req = req.WithContext(ctx)
	resp, err := c.httpclient.Do(req)
	if err != nil {
		return nil, errors.Wrap(err, "FaceboxClient.Rename: do")
	}
	if resp.StatusCode != http.StatusOK {
		resp.Body.Close()
		return nil, errors.Errorf("FaceboxClient.Rename: remote service returned %s", resp.Status)
	}
	b, err = ioutil.ReadAll(resp.Body)
	resp.Body.Close()
	if err != nil {
		return nil, errors.Wrap(err, "FaceboxClient.Rename: read response body")
	}
	var resps []*RenameResponse
	if err := json.Unmarshal(b, &resps); err != nil {
		return nil, errors.Wrap(err, "FaceboxClient.Rename: decode response body")
	}
	return resps, nil
}

func (c *FaceboxClient) RenameID(ctx context.Context, request *RenameIDRequest) (*RenameIDResponse, error) {
	resp, err := c.RenameIDMulti(ctx, []*RenameIDRequest{request})
	if err != nil {
		return nil, err
	}
	if len(resp) == 0 {
		return nil, errors.New("FaceboxClient.RenameID: no response")
	}
	return resp[0], nil
}

func (c *FaceboxClient) RenameIDMulti(ctx context.Context, requests []*RenameIDRequest) ([]*RenameIDResponse, error) {
	b, err := json.Marshal(requests)
	if err != nil {
		return nil, errors.Wrap(err, "FaceboxClient.RenameID: encode request")
	}
	buf := c.bufs.Get()
	defer c.bufs.Put(buf)
	w := multipart.NewWriter(buf)
	w.WriteField("json", string(b))
	if files, ok := ctx.Value(contextKeyFiles).(map[string]file); ok {
		for fieldname, file := range files {
			f, err := w.CreateFormFile(fieldname, file.filename)
			if err != nil {
				return nil, errors.Wrap(err, "FaceboxClient.RenameID: create form file")
			}
			if _, err := io.Copy(f, file.r); err != nil {
				return nil, errors.Wrap(err, "FaceboxClient.RenameID: reading file")
			}
			select {
			case <-ctx.Done():
				return nil, ctx.Err()
			default:
			}
		}
	}
	if err := w.Close(); err != nil {
		return nil, errors.Wrap(err, "FaceboxClient.RenameID: write")
	}
	req, err := http.NewRequest(http.MethodPost, c.endpoint+"/remoto/Facebox.RenameID", buf)
	if err != nil {
		return nil, errors.Wrap(err, "FaceboxClient.RenameID: new request")
	}
	req.Header.Set("Accept", "application/json; charset=utf-8")
	req.Header.Set("Content-Type", w.FormDataContentType())
	req = req.WithContext(ctx)
	resp, err := c.httpclient.Do(req)
	if err != nil {
		return nil, errors.Wrap(err, "FaceboxClient.RenameID: do")
	}
	if resp.StatusCode != http.StatusOK {
		resp.Body.Close()
		return nil, errors.Errorf("FaceboxClient.RenameID: remote service returned %s", resp.Status)
	}
	b, err = ioutil.ReadAll(resp.Body)
	resp.Body.Close()
	if err != nil {
		return nil, errors.Wrap(err, "FaceboxClient.RenameID: read response body")
	}
	var resps []*RenameIDResponse
	if err := json.Unmarshal(b, &resps); err != nil {
		return nil, errors.Wrap(err, "FaceboxClient.RenameID: decode response body")
	}
	return resps, nil
}

func (c *FaceboxClient) SimilarFile(ctx context.Context, request *SimilarFileRequest) (*SimilarFileResponse, error) {
	resp, err := c.SimilarFileMulti(ctx, []*SimilarFileRequest{request})
	if err != nil {
		return nil, err
	}
	if len(resp) == 0 {
		return nil, errors.New("FaceboxClient.SimilarFile: no response")
	}
	return resp[0], nil
}

func (c *FaceboxClient) SimilarFileMulti(ctx context.Context, requests []*SimilarFileRequest) ([]*SimilarFileResponse, error) {
	b, err := json.Marshal(requests)
	if err != nil {
		return nil, errors.Wrap(err, "FaceboxClient.SimilarFile: encode request")
	}
	buf := c.bufs.Get()
	defer c.bufs.Put(buf)
	w := multipart.NewWriter(buf)
	w.WriteField("json", string(b))
	if files, ok := ctx.Value(contextKeyFiles).(map[string]file); ok {
		for fieldname, file := range files {
			f, err := w.CreateFormFile(fieldname, file.filename)
			if err != nil {
				return nil, errors.Wrap(err, "FaceboxClient.SimilarFile: create form file")
			}
			if _, err := io.Copy(f, file.r); err != nil {
				return nil, errors.Wrap(err, "FaceboxClient.SimilarFile: reading file")
			}
			select {
			case <-ctx.Done():
				return nil, ctx.Err()
			default:
			}
		}
	}
	if err := w.Close(); err != nil {
		return nil, errors.Wrap(err, "FaceboxClient.SimilarFile: write")
	}
	req, err := http.NewRequest(http.MethodPost, c.endpoint+"/remoto/Facebox.SimilarFile", buf)
	if err != nil {
		return nil, errors.Wrap(err, "FaceboxClient.SimilarFile: new request")
	}
	req.Header.Set("Accept", "application/json; charset=utf-8")
	req.Header.Set("Content-Type", w.FormDataContentType())
	req = req.WithContext(ctx)
	resp, err := c.httpclient.Do(req)
	if err != nil {
		return nil, errors.Wrap(err, "FaceboxClient.SimilarFile: do")
	}
	if resp.StatusCode != http.StatusOK {
		resp.Body.Close()
		return nil, errors.Errorf("FaceboxClient.SimilarFile: remote service returned %s", resp.Status)
	}
	b, err = ioutil.ReadAll(resp.Body)
	resp.Body.Close()
	if err != nil {
		return nil, errors.Wrap(err, "FaceboxClient.SimilarFile: read response body")
	}
	var resps []*SimilarFileResponse
	if err := json.Unmarshal(b, &resps); err != nil {
		return nil, errors.Wrap(err, "FaceboxClient.SimilarFile: decode response body")
	}
	return resps, nil
}

func (c *FaceboxClient) SimilarID(ctx context.Context, request *SimilarIDRequest) (*SimilarIDResponse, error) {
	resp, err := c.SimilarIDMulti(ctx, []*SimilarIDRequest{request})
	if err != nil {
		return nil, err
	}
	if len(resp) == 0 {
		return nil, errors.New("FaceboxClient.SimilarID: no response")
	}
	return resp[0], nil
}

func (c *FaceboxClient) SimilarIDMulti(ctx context.Context, requests []*SimilarIDRequest) ([]*SimilarIDResponse, error) {
	b, err := json.Marshal(requests)
	if err != nil {
		return nil, errors.Wrap(err, "FaceboxClient.SimilarID: encode request")
	}
	buf := c.bufs.Get()
	defer c.bufs.Put(buf)
	w := multipart.NewWriter(buf)
	w.WriteField("json", string(b))
	if files, ok := ctx.Value(contextKeyFiles).(map[string]file); ok {
		for fieldname, file := range files {
			f, err := w.CreateFormFile(fieldname, file.filename)
			if err != nil {
				return nil, errors.Wrap(err, "FaceboxClient.SimilarID: create form file")
			}
			if _, err := io.Copy(f, file.r); err != nil {
				return nil, errors.Wrap(err, "FaceboxClient.SimilarID: reading file")
			}
			select {
			case <-ctx.Done():
				return nil, ctx.Err()
			default:
			}
		}
	}
	if err := w.Close(); err != nil {
		return nil, errors.Wrap(err, "FaceboxClient.SimilarID: write")
	}
	req, err := http.NewRequest(http.MethodPost, c.endpoint+"/remoto/Facebox.SimilarID", buf)
	if err != nil {
		return nil, errors.Wrap(err, "FaceboxClient.SimilarID: new request")
	}
	req.Header.Set("Accept", "application/json; charset=utf-8")
	req.Header.Set("Content-Type", w.FormDataContentType())
	req = req.WithContext(ctx)
	resp, err := c.httpclient.Do(req)
	if err != nil {
		return nil, errors.Wrap(err, "FaceboxClient.SimilarID: do")
	}
	if resp.StatusCode != http.StatusOK {
		resp.Body.Close()
		return nil, errors.Errorf("FaceboxClient.SimilarID: remote service returned %s", resp.Status)
	}
	b, err = ioutil.ReadAll(resp.Body)
	resp.Body.Close()
	if err != nil {
		return nil, errors.Wrap(err, "FaceboxClient.SimilarID: read response body")
	}
	var resps []*SimilarIDResponse
	if err := json.Unmarshal(b, &resps); err != nil {
		return nil, errors.Wrap(err, "FaceboxClient.SimilarID: decode response body")
	}
	return resps, nil
}

func (c *FaceboxClient) SimilarURL(ctx context.Context, request *SimilarURLRequest) (*SimilarURLResponse, error) {
	resp, err := c.SimilarURLMulti(ctx, []*SimilarURLRequest{request})
	if err != nil {
		return nil, err
	}
	if len(resp) == 0 {
		return nil, errors.New("FaceboxClient.SimilarURL: no response")
	}
	return resp[0], nil
}

func (c *FaceboxClient) SimilarURLMulti(ctx context.Context, requests []*SimilarURLRequest) ([]*SimilarURLResponse, error) {
	b, err := json.Marshal(requests)
	if err != nil {
		return nil, errors.Wrap(err, "FaceboxClient.SimilarURL: encode request")
	}
	buf := c.bufs.Get()
	defer c.bufs.Put(buf)
	w := multipart.NewWriter(buf)
	w.WriteField("json", string(b))
	if files, ok := ctx.Value(contextKeyFiles).(map[string]file); ok {
		for fieldname, file := range files {
			f, err := w.CreateFormFile(fieldname, file.filename)
			if err != nil {
				return nil, errors.Wrap(err, "FaceboxClient.SimilarURL: create form file")
			}
			if _, err := io.Copy(f, file.r); err != nil {
				return nil, errors.Wrap(err, "FaceboxClient.SimilarURL: reading file")
			}
			select {
			case <-ctx.Done():
				return nil, ctx.Err()
			default:
			}
		}
	}
	if err := w.Close(); err != nil {
		return nil, errors.Wrap(err, "FaceboxClient.SimilarURL: write")
	}
	req, err := http.NewRequest(http.MethodPost, c.endpoint+"/remoto/Facebox.SimilarURL", buf)
	if err != nil {
		return nil, errors.Wrap(err, "FaceboxClient.SimilarURL: new request")
	}
	req.Header.Set("Accept", "application/json; charset=utf-8")
	req.Header.Set("Content-Type", w.FormDataContentType())
	req = req.WithContext(ctx)
	resp, err := c.httpclient.Do(req)
	if err != nil {
		return nil, errors.Wrap(err, "FaceboxClient.SimilarURL: do")
	}
	if resp.StatusCode != http.StatusOK {
		resp.Body.Close()
		return nil, errors.Errorf("FaceboxClient.SimilarURL: remote service returned %s", resp.Status)
	}
	b, err = ioutil.ReadAll(resp.Body)
	resp.Body.Close()
	if err != nil {
		return nil, errors.Wrap(err, "FaceboxClient.SimilarURL: read response body")
	}
	var resps []*SimilarURLResponse
	if err := json.Unmarshal(b, &resps); err != nil {
		return nil, errors.Wrap(err, "FaceboxClient.SimilarURL: decode response body")
	}
	return resps, nil
}

func (c *FaceboxClient) TeachFaceprint(ctx context.Context, request *TeachFaceprintRequest) (*TeachFaceprintResponse, error) {
	resp, err := c.TeachFaceprintMulti(ctx, []*TeachFaceprintRequest{request})
	if err != nil {
		return nil, err
	}
	if len(resp) == 0 {
		return nil, errors.New("FaceboxClient.TeachFaceprint: no response")
	}
	return resp[0], nil
}

func (c *FaceboxClient) TeachFaceprintMulti(ctx context.Context, requests []*TeachFaceprintRequest) ([]*TeachFaceprintResponse, error) {
	b, err := json.Marshal(requests)
	if err != nil {
		return nil, errors.Wrap(err, "FaceboxClient.TeachFaceprint: encode request")
	}
	buf := c.bufs.Get()
	defer c.bufs.Put(buf)
	w := multipart.NewWriter(buf)
	w.WriteField("json", string(b))
	if files, ok := ctx.Value(contextKeyFiles).(map[string]file); ok {
		for fieldname, file := range files {
			f, err := w.CreateFormFile(fieldname, file.filename)
			if err != nil {
				return nil, errors.Wrap(err, "FaceboxClient.TeachFaceprint: create form file")
			}
			if _, err := io.Copy(f, file.r); err != nil {
				return nil, errors.Wrap(err, "FaceboxClient.TeachFaceprint: reading file")
			}
			select {
			case <-ctx.Done():
				return nil, ctx.Err()
			default:
			}
		}
	}
	if err := w.Close(); err != nil {
		return nil, errors.Wrap(err, "FaceboxClient.TeachFaceprint: write")
	}
	req, err := http.NewRequest(http.MethodPost, c.endpoint+"/remoto/Facebox.TeachFaceprint", buf)
	if err != nil {
		return nil, errors.Wrap(err, "FaceboxClient.TeachFaceprint: new request")
	}
	req.Header.Set("Accept", "application/json; charset=utf-8")
	req.Header.Set("Content-Type", w.FormDataContentType())
	req = req.WithContext(ctx)
	resp, err := c.httpclient.Do(req)
	if err != nil {
		return nil, errors.Wrap(err, "FaceboxClient.TeachFaceprint: do")
	}
	if resp.StatusCode != http.StatusOK {
		resp.Body.Close()
		return nil, errors.Errorf("FaceboxClient.TeachFaceprint: remote service returned %s", resp.Status)
	}
	b, err = ioutil.ReadAll(resp.Body)
	resp.Body.Close()
	if err != nil {
		return nil, errors.Wrap(err, "FaceboxClient.TeachFaceprint: read response body")
	}
	var resps []*TeachFaceprintResponse
	if err := json.Unmarshal(b, &resps); err != nil {
		return nil, errors.Wrap(err, "FaceboxClient.TeachFaceprint: decode response body")
	}
	return resps, nil
}

func (c *FaceboxClient) TeachFile(ctx context.Context, request *TeachFileRequest) (*TeachFileResponse, error) {
	resp, err := c.TeachFileMulti(ctx, []*TeachFileRequest{request})
	if err != nil {
		return nil, err
	}
	if len(resp) == 0 {
		return nil, errors.New("FaceboxClient.TeachFile: no response")
	}
	return resp[0], nil
}

func (c *FaceboxClient) TeachFileMulti(ctx context.Context, requests []*TeachFileRequest) ([]*TeachFileResponse, error) {
	b, err := json.Marshal(requests)
	if err != nil {
		return nil, errors.Wrap(err, "FaceboxClient.TeachFile: encode request")
	}
	buf := c.bufs.Get()
	defer c.bufs.Put(buf)
	w := multipart.NewWriter(buf)
	w.WriteField("json", string(b))
	if files, ok := ctx.Value(contextKeyFiles).(map[string]file); ok {
		for fieldname, file := range files {
			f, err := w.CreateFormFile(fieldname, file.filename)
			if err != nil {
				return nil, errors.Wrap(err, "FaceboxClient.TeachFile: create form file")
			}
			if _, err := io.Copy(f, file.r); err != nil {
				return nil, errors.Wrap(err, "FaceboxClient.TeachFile: reading file")
			}
			select {
			case <-ctx.Done():
				return nil, ctx.Err()
			default:
			}
		}
	}
	if err := w.Close(); err != nil {
		return nil, errors.Wrap(err, "FaceboxClient.TeachFile: write")
	}
	req, err := http.NewRequest(http.MethodPost, c.endpoint+"/remoto/Facebox.TeachFile", buf)
	if err != nil {
		return nil, errors.Wrap(err, "FaceboxClient.TeachFile: new request")
	}
	req.Header.Set("Accept", "application/json; charset=utf-8")
	req.Header.Set("Content-Type", w.FormDataContentType())
	req = req.WithContext(ctx)
	resp, err := c.httpclient.Do(req)
	if err != nil {
		return nil, errors.Wrap(err, "FaceboxClient.TeachFile: do")
	}
	if resp.StatusCode != http.StatusOK {
		resp.Body.Close()
		return nil, errors.Errorf("FaceboxClient.TeachFile: remote service returned %s", resp.Status)
	}
	b, err = ioutil.ReadAll(resp.Body)
	resp.Body.Close()
	if err != nil {
		return nil, errors.Wrap(err, "FaceboxClient.TeachFile: read response body")
	}
	var resps []*TeachFileResponse
	if err := json.Unmarshal(b, &resps); err != nil {
		return nil, errors.Wrap(err, "FaceboxClient.TeachFile: decode response body")
	}
	return resps, nil
}

func (c *FaceboxClient) TeachURL(ctx context.Context, request *TeachURLRequest) (*TeachURLResponse, error) {
	resp, err := c.TeachURLMulti(ctx, []*TeachURLRequest{request})
	if err != nil {
		return nil, err
	}
	if len(resp) == 0 {
		return nil, errors.New("FaceboxClient.TeachURL: no response")
	}
	return resp[0], nil
}

func (c *FaceboxClient) TeachURLMulti(ctx context.Context, requests []*TeachURLRequest) ([]*TeachURLResponse, error) {
	b, err := json.Marshal(requests)
	if err != nil {
		return nil, errors.Wrap(err, "FaceboxClient.TeachURL: encode request")
	}
	buf := c.bufs.Get()
	defer c.bufs.Put(buf)
	w := multipart.NewWriter(buf)
	w.WriteField("json", string(b))
	if files, ok := ctx.Value(contextKeyFiles).(map[string]file); ok {
		for fieldname, file := range files {
			f, err := w.CreateFormFile(fieldname, file.filename)
			if err != nil {
				return nil, errors.Wrap(err, "FaceboxClient.TeachURL: create form file")
			}
			if _, err := io.Copy(f, file.r); err != nil {
				return nil, errors.Wrap(err, "FaceboxClient.TeachURL: reading file")
			}
			select {
			case <-ctx.Done():
				return nil, ctx.Err()
			default:
			}
		}
	}
	if err := w.Close(); err != nil {
		return nil, errors.Wrap(err, "FaceboxClient.TeachURL: write")
	}
	req, err := http.NewRequest(http.MethodPost, c.endpoint+"/remoto/Facebox.TeachURL", buf)
	if err != nil {
		return nil, errors.Wrap(err, "FaceboxClient.TeachURL: new request")
	}
	req.Header.Set("Accept", "application/json; charset=utf-8")
	req.Header.Set("Content-Type", w.FormDataContentType())
	req = req.WithContext(ctx)
	resp, err := c.httpclient.Do(req)
	if err != nil {
		return nil, errors.Wrap(err, "FaceboxClient.TeachURL: do")
	}
	if resp.StatusCode != http.StatusOK {
		resp.Body.Close()
		return nil, errors.Errorf("FaceboxClient.TeachURL: remote service returned %s", resp.Status)
	}
	b, err = ioutil.ReadAll(resp.Body)
	resp.Body.Close()
	if err != nil {
		return nil, errors.Wrap(err, "FaceboxClient.TeachURL: read response body")
	}
	var resps []*TeachURLResponse
	if err := json.Unmarshal(b, &resps); err != nil {
		return nil, errors.Wrap(err, "FaceboxClient.TeachURL: decode response body")
	}
	return resps, nil
}

type CheckFaceprintRequest struct {
	Faceprints []string `json:"faceprints"`
}

type SimilarURLResponse struct {
	Faces []SimilarFace `json:"faces"`
	// Error is an error message if one occurred.
	Error string `json:"error"`
}

type TeachURLRequest struct {
	ID   string `json:"id"`
	Name string `json:"name"`
	URL  string `json:"url"`
}

type TeachFaceprintResponse struct {

	// Error is an error message if one occurred.
	Error string `json:"error"`
}

type FaceprintFace struct {
	Matched    bool    `json:"matched"`
	Confidence float64 `json:"confidence"`
	ID         string  `json:"id"`
	Name       string  `json:"name"`
}

type CheckURLRequest struct {
	File remototypes.File `json:"file"`
}

// SetFile sets the file for the File field.
func (s *CheckURLRequest) SetFile(ctx context.Context, filename string, r io.Reader) context.Context {
	files, ok := ctx.Value(contextKeyFiles).(map[string]file)
	if !ok {
		files = make(map[string]file)
	}
	fieldname := "files[" + strconv.Itoa(len(files)) + "]"
	files[fieldname] = file{r: r, filename: filename}
	ctx = context.WithValue(ctx, contextKeyFiles, files)
	s.File = remototypes.File{
		Fieldname: fieldname,
		Filename:  filename,
	}
	return ctx
}

type SimilarIDRequest struct {
	ID string `json:"id"`
}

type RenameResponse struct {

	// Error is an error message if one occurred.
	Error string `json:"error"`
}

type SimilarURLRequest struct {
	URL string `json:"url"`
}

type TeachFileRequest struct {
	ID   string           `json:"id"`
	Name string           `json:"name"`
	File remototypes.File `json:"file"`
}

// SetFile sets the file for the File field.
func (s *TeachFileRequest) SetFile(ctx context.Context, filename string, r io.Reader) context.Context {
	files, ok := ctx.Value(contextKeyFiles).(map[string]file)
	if !ok {
		files = make(map[string]file)
	}
	fieldname := "files[" + strconv.Itoa(len(files)) + "]"
	files[fieldname] = file{r: r, filename: filename}
	ctx = context.WithValue(ctx, contextKeyFiles, files)
	s.File = remototypes.File{
		Fieldname: fieldname,
		Filename:  filename,
	}
	return ctx
}

type CheckURLResponse struct {
	Faces []Face `json:"faces"`
	// Error is an error message if one occurred.
	Error string `json:"error"`
}

type PutStateResponse struct {

	// Error is an error message if one occurred.
	Error string `json:"error"`
}

type RemoveIDRequest struct {
	ID string `json:"id"`
}

type Rect struct {
	Top    int `json:"top"`
	Left   int `json:"left"`
	Width  int `json:"width"`
	Height int `json:"height"`
}

type PutStateRequest struct {
	StateFile remototypes.File `json:"state_file"`
}

// SetStateFile sets the file for the StateFile field.
func (s *PutStateRequest) SetStateFile(ctx context.Context, filename string, r io.Reader) context.Context {
	files, ok := ctx.Value(contextKeyFiles).(map[string]file)
	if !ok {
		files = make(map[string]file)
	}
	fieldname := "files[" + strconv.Itoa(len(files)) + "]"
	files[fieldname] = file{r: r, filename: filename}
	ctx = context.WithValue(ctx, contextKeyFiles, files)
	s.StateFile = remototypes.File{
		Fieldname: fieldname,
		Filename:  filename,
	}
	return ctx
}

type SimilarFileRequest struct {
	File remototypes.File `json:"file"`
}

// SetFile sets the file for the File field.
func (s *SimilarFileRequest) SetFile(ctx context.Context, filename string, r io.Reader) context.Context {
	files, ok := ctx.Value(contextKeyFiles).(map[string]file)
	if !ok {
		files = make(map[string]file)
	}
	fieldname := "files[" + strconv.Itoa(len(files)) + "]"
	files[fieldname] = file{r: r, filename: filename}
	ctx = context.WithValue(ctx, contextKeyFiles, files)
	s.File = remototypes.File{
		Fieldname: fieldname,
		Filename:  filename,
	}
	return ctx
}

type CheckFileResponse struct {
	Faces []Face `json:"faces"`
	// Error is an error message if one occurred.
	Error string `json:"error"`
}

type SimilarFace struct {
	Rect         Rect   `json:"rect"`
	SimilarFaces []Face `json:"similar_faces"`
}

type Face struct {
	ID        string `json:"id"`
	Name      string `json:"name"`
	Matched   bool   `json:"matched"`
	Faceprint string `json:"faceprint"`
	Rect      Rect   `json:"rect"`
}

type GetStateRequest struct {
}

type RenameIDRequest struct {
	ID   string `json:"id"`
	Name string `json:"name"`
}

type FaceprintCompareResponse struct {
	Confidences []float64 `json:"confidences"`
	// Error is an error message if one occurred.
	Error string `json:"error"`
}

type RemoveIDResponse struct {

	// Error is an error message if one occurred.
	Error string `json:"error"`
}

type RenameIDResponse struct {

	// Error is an error message if one occurred.
	Error string `json:"error"`
}

type TeachFaceprintRequest struct {
	ID        string `json:"id"`
	Name      string `json:"name"`
	Faceprint string `json:"faceprint"`
}

type TeachURLResponse struct {

	// Error is an error message if one occurred.
	Error string `json:"error"`
}

type CheckFaceprintResponse struct {
	Faces []FaceprintFace `json:"faces"`
	// Error is an error message if one occurred.
	Error string `json:"error"`
}

type CheckFileRequest struct {
	File remototypes.File `json:"file"`
}

// SetFile sets the file for the File field.
func (s *CheckFileRequest) SetFile(ctx context.Context, filename string, r io.Reader) context.Context {
	files, ok := ctx.Value(contextKeyFiles).(map[string]file)
	if !ok {
		files = make(map[string]file)
	}
	fieldname := "files[" + strconv.Itoa(len(files)) + "]"
	files[fieldname] = file{r: r, filename: filename}
	ctx = context.WithValue(ctx, contextKeyFiles, files)
	s.File = remototypes.File{
		Fieldname: fieldname,
		Filename:  filename,
	}
	return ctx
}

type FaceprintCompareRequest struct {
	Target     string   `json:"target"`
	Faceprints []string `json:"faceprints"`
}

type TeachFileResponse struct {

	// Error is an error message if one occurred.
	Error string `json:"error"`
}

type RenameRequest struct {
	From string `json:"from"`
	To   string `json:"to"`
}

type SimilarFileResponse struct {
	Faces []SimilarFace `json:"faces"`
	// Error is an error message if one occurred.
	Error string `json:"error"`
}

type SimilarIDResponse struct {
	Faces []SimilarFace `json:"faces"`
	// Error is an error message if one occurred.
	Error string `json:"error"`
}

// contextKey is a local context key type.
// see https://medium.com/@matryer/context-keys-in-go-5312346a868d
type contextKey string

func (c contextKey) String() string {
	return "remoto context key: " + string(c)
}

// contextKeyFiles is the context key for the request files.
var contextKeyFiles = contextKey("files")

// file holds info about a file in the context, including
// the io.Reader where the contents will be read from.
type file struct {
	r        io.Reader
	filename string
}

// this is here so we don't get a compiler complaints.
func init() {
	var _ = remototypes.File{}
	var _ = strconv.Itoa(0)
	var _ = ioutil.Discard
}
