<%# 

	This is a plush template
	see https://github.com/gobuffalo/plush

%><%

let comment = fn(s) {
	return "// "+s
}

let serverName = fn(serviceName) {
	return serviceName + "Server"
}

let typeString = fn(type) {
	if (type.IsMultiple) {
		return "[]" + type.Name
	}
	return type.Name
}

%>// This file was autogenerated
// by remoto
// DO NOT EDIT

package <%= def.PackageName %>

import (
	"context"
	"encoding/json"
	"net/http"
	"io"
	"io/ioutil"
	"os"

	"github.com/matryer/remoto/go/remotohttpjson"
	"github.com/pkg/errors"
)

// Run is the simplest way to run the services.
func Run(addr string, <%= for (service) in def.Services { %>
	<%= camelize_down_first(service.Name) %> <%= service.Name %>,
<% } %>) error {
	server := New(<%= for (service) in def.Services { %>
		<%= camelize_down_first(service.Name) %>,
	<% } %>)
	if err := server.Describe(os.Stdout, "endpoint:"); err != nil {
		return errors.Wrap(err, "describe service")
	}
	if err := http.ListenAndServe(addr, server); err != nil {
		return err
	}
	return nil
}

// New makes a new remotohttpjson.Server with the specified services
// registered.
func New(<%= for (service) in def.Services { %>
	<%= camelize_down_first(service.Name) %> <%= service.Name %>,
<% } %>) *remotohttpjson.Server {
	server := remotohttpjson.NewServer()<%= for (service) in def.Services { %>
	Register<%= service.Name %>Server(server, <%= camelize_down_first(service.Name) %>)<% } %>
	return server
}

<%= for (structure) in unique_structures(def) { %><%= comment(structure.Comment) %>
type <%= structure.Name %> struct {
	<%= for (field) in structure.Fields { %><%= comment(field.Comment) %>
	<%= field.Name %> <%= typeString(field.Type) %> `json:"<%= underscore(field.Name) %>"`
	<% } %>
}

<% } %>

<%= for (service) in def.Services { %><%= comment(service.Comment) %>
type <%= service.Name %> interface {
	<%= for (method) in service.Methods { %><%= comment(method.Comment) %>
	<%= method.Name %>(context.Context, *<%= method.RequestType %>) (*<%= method.ResponseType %>, error)
<% } %>
}

// Register<%= service.Name %>Server registers a <%= service.Name %> with a remotohttpjson.Server.
func Register<%= service.Name %>Server(server *remotohttpjson.Server, service <%= service.Name %>) {
	srv := &httpjson<%= service.Name %>Server{service: service}
	<%= for (method) in service.Methods { %>
	server.Register("/remoto/<%= service.Name %>.<%= method.Name %>", srv.<%= method.Name %>)
	<% } %>
}

type httpjson<%= service.Name %>Server struct {
	service <%= service.Name %>
}

<%= for (method) in service.Methods { %>
// <%= method.Name %> is a remotohttpjson.HandlerFunc wrapper for <%= service.Name %>.<%= method.Name %>.
func (srv *httpjson<%= service.Name %>Server) <%= method.Name %>(ctx context.Context, w io.Writer, r io.Reader) error {
	var reqs []*<%= method.RequestType %>
	b, err := ioutil.ReadAll(r)
	if err != nil {
		return errors.Wrap(err, "read request")
	}
	if err = json.Unmarshal(b, &reqs); err != nil {
		return errors.Wrap(err, "decode request")
	}
	resps := make([]<%= method.ResponseType %>, len(reqs))
	for i := range reqs {
		resp, err := srv.service.<%= method.Name %>(ctx, reqs[i])
		if err != nil {
			resps[i].Error = err.Error()
			continue
		}
		resps[i] = *resp
	}
	if b, err = json.Marshal(resps); err != nil {
		return errors.Wrap(err, "encode response")
	}
	if _, err = w.Write(b); err != nil {
		return errors.Wrap(err, "write response")
	}
	return nil
}
<% } %> 

<% } %>